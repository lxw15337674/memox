// DEPRECATED: This script uses Prisma and is no longer compatible with the new Drizzle schema
// TODO: Rewrite this script to use Drizzle ORM with string IDs

/*
import { PrismaClient } from "@prisma/client";
import { withAccelerate } from "@prisma/extension-accelerate";
import { db, memos, tags, links, memoTags, syncMetadata } from "../src/db";
import { eq, sql } from "drizzle-orm";
import axios from "axios";
import dotenv from "dotenv";

dotenv.config();

// Prisma client setup
const prisma = new PrismaClient().$extends(withAccelerate());

// API configuration for embeddings
const siliconflowApiKey = process.env.SILICONFLOW_API_KEY;
const SILICONFLOW_API_URL = "https://api.siliconflow.cn/v1/embeddings";
const EMBEDDING_MODEL = "Qwen/Qwen3-Embedding-4B";
const BATCH_SIZE = 32;

if (!siliconflowApiKey) {
    throw new Error("ç¯å¢ƒå˜é‡ä¸­æœªå®šä¹‰ SILICONFLOW_API_KEYã€‚");
}

console.log("ğŸ”§ ç¯å¢ƒè®¾ç½®æ£€æŸ¥ï¼š");
console.log("- TURSO æ•°æ®åº“åœ°å€:", process.env.TURSO_DATABASE_URL ? "âœ… å·²è®¾ç½®" : "âŒ æœªè®¾ç½®");
console.log("- TURSO è®¤è¯ä»¤ç‰Œ:", process.env.TURSO_AUTH_TOKEN ? "âœ… å·²è®¾ç½®" : "âŒ æœªè®¾ç½®");
console.log("- SiliconFlow API å¯†é’¥:", process.env.SILICONFLOW_API_KEY ? "âœ… å·²è®¾ç½®" : "âŒ æœªè®¾ç½®");

/**
 * Generate embeddings for text content
 */
async function getEmbeddings(texts: string[]): Promise<number[][]> {
    if (texts.length === 0) return [];
    
    try {
        const response = await axios.post(
            SILICONFLOW_API_URL,
            {
                model: EMBEDDING_MODEL,
                input: texts,
                encoding_format: "float",
            },
            {
                headers: {
                    "Authorization": `Bearer ${siliconflowApiKey}`,
                    "Content-Type": "application/json",
                },
                timeout: 60000,
            }
        );

        if (response.data?.data) {
            return response.data.data.map((item: any) => item.embedding);
        } else {
            throw new Error("API å“åº”æ ¼å¼ä¸æ­£ç¡®");
        }
    } catch (error: any) {
        console.error("å‘é‡ç”Ÿæˆå¤±è´¥:", error.response?.data || error.message);
        throw error;
    }
}

/**
 * Migrate all data from Prisma/PostgreSQL to Drizzle/Turso
 */
async function migrateAllData() {
    const startTime = Date.now();
    console.log("ğŸš€ å¼€å§‹å®Œæ•´æ•°æ®è¿ç§»...");

    try {
        // 1. Clear existing data in Turso (if any)
        console.log("ğŸ§¹ æ¸…ç†ç›®æ ‡æ•°æ®åº“...");
        await db.delete(memoTags);
        await db.delete(links);
        await db.delete(memos);
        await db.delete(tags);
        await db.delete(syncMetadata);
        console.log("âœ… ç›®æ ‡æ•°æ®åº“å·²æ¸…ç†");

        // 2. Migrate tags first
        console.log("ğŸ·ï¸ å¼€å§‹è¿ç§»æ ‡ç­¾...");
        const prismaTagsData = await prisma.tag.findMany();
        
        if (prismaTagsData.length > 0) {
            const tagsToInsert = prismaTagsData.map(tag => ({
                id: Number(tag.id),
                name: tag.name,
                createdAt: tag.createdAt.toISOString(),
            }));
            
            await db.insert(tags).values(tagsToInsert);
            console.log(`âœ… å·²è¿ç§» ${prismaTagsData.length} ä¸ªæ ‡ç­¾`);
        }

        // 3. Migrate memos with embeddings
        console.log("ğŸ“ å¼€å§‹è¿ç§»ç¬”è®°...");
        const prismaMemosData = await prisma.memo.findMany({
            where: { deleted_at: null },
            include: { tags: true, link: true }
        });

        if (prismaMemosData.length > 0) {
            console.log(`ğŸ“Š æ€»å…±éœ€è¦è¿ç§» ${prismaMemosData.length} æ¡ç¬”è®°`);
            
            // Process memos in batches
            for (let i = 0; i < prismaMemosData.length; i += BATCH_SIZE) {
                const batchMemos = prismaMemosData.slice(i, i + BATCH_SIZE);
                const batchNumber = Math.floor(i / BATCH_SIZE) + 1;
                const totalBatches = Math.ceil(prismaMemosData.length / BATCH_SIZE);
                
                console.log(`  - æ‰¹æ¬¡ ${batchNumber}/${totalBatches}: å¤„ç† ${batchMemos.length} æ¡ç¬”è®°`);

                // Generate embeddings for this batch
                console.log(`    ğŸ”„ æ­£åœ¨ä¸ºæ‰¹æ¬¡ç”Ÿæˆå‘é‡...`);
                const contents = batchMemos.map(memo => memo.content.trim());
                const embeddings = await getEmbeddings(contents);
                
                if (embeddings.length !== batchMemos.length) {
                    throw new Error(`æ‰¹æ¬¡ ${batchNumber} çš„å‘é‡æ•°é‡(${embeddings.length})ä¸ç¬”è®°æ•°é‡(${batchMemos.length})ä¸åŒ¹é…`);
                }

                // Insert memos
                const memosToInsert = batchMemos.map((memo, index) => {
                    const embedding = embeddings[index];
                    const embeddingBuffer = embedding ? Buffer.from(new Float32Array(embedding).buffer) : null;
                    
                    return {
                        id: Number(memo.id),
                        content: memo.content,
                        images: JSON.stringify(memo.images),
                        createdAt: memo.createdAt.toISOString(),
                        updatedAt: memo.updatedAt.toISOString(),
                        deletedAt: memo.deleted_at?.toISOString() || null,
                        embedding: embeddingBuffer,
                    };
                });
                
                await db.insert(memos).values(memosToInsert);
                console.log(`    âœ… æ‰¹æ¬¡ ${batchNumber} ç¬”è®°è¿ç§»å®Œæˆ`);
            }
        }

        // 4. Migrate links
        console.log("ğŸ”— å¼€å§‹è¿ç§»é“¾æ¥...");
        const prismaLinksData = await prisma.link.findMany();
        
        if (prismaLinksData.length > 0) {
            const linksToInsert = prismaLinksData.map(link => ({
                id: Number(link.id),
                link: link.url,
                text: link.text,
                memoId: Number(link.memoId),
                createdAt: link.createdAt.toISOString(),
            }));
            
            await db.insert(links).values(linksToInsert);
            console.log(`âœ… å·²è¿ç§» ${prismaLinksData.length} ä¸ªé“¾æ¥`);
        }

        // 5. Migrate memo-tag relationships
        console.log("ğŸ”— å¼€å§‹è¿ç§»ç¬”è®°-æ ‡ç­¾å…³ç³»...");
        const memoTagRelations: { memoId: number; tagId: number }[] = [];
        
        for (const memo of prismaMemosData) {
            for (const tag of memo.tags) {
                memoTagRelations.push({
                    memoId: Number(memo.id),
                    tagId: Number(tag.id),
                });
            }
        }
        
        if (memoTagRelations.length > 0) {
            await db.insert(memoTags).values(memoTagRelations);
            console.log(`âœ… å·²è¿ç§» ${memoTagRelations.length} ä¸ªç¬”è®°-æ ‡ç­¾å…³ç³»`);
        }

        // 6. Set sync metadata
        console.log("ğŸ’¾ è®¾ç½®åŒæ­¥å…ƒæ•°æ®...");
        await db.insert(syncMetadata).values({
            key: "last_successful_sync",
            value: new Date().toISOString(),
        });
        
        await db.insert(syncMetadata).values({
            key: "migration_completed",
            value: new Date().toISOString(),
        });

        const duration = (Date.now() - startTime) / 1000;
        console.log(`\nğŸ‰ æ•°æ®è¿ç§»å®Œæˆï¼è€—æ—¶: ${duration.toFixed(2)} ç§’`);
        console.log(`ğŸ“Š è¿ç§»ç»Ÿè®¡:`);
        console.log(`  - æ ‡ç­¾: ${prismaTagsData.length}`);
        console.log(`  - ç¬”è®°: ${prismaMemosData.length}`);
        console.log(`  - é“¾æ¥: ${prismaLinksData.length}`);
        console.log(`  - å…³ç³»: ${memoTagRelations.length}`);

    } catch (error) {
        console.error("\nâŒ è¿ç§»è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:", error);
        throw error;
    } finally {
        await prisma.$disconnect();
        console.log("âœ… æ•°æ®åº“è¿æ¥å·²å…³é—­");
    }
}

// Run migration
if (require.main === module) {
    migrateAllData()
        .then(() => {
            console.log("ğŸŠ è¿ç§»è„šæœ¬æ‰§è¡Œå®Œæˆ");
            process.exit(0);
        })
        .catch((error) => {
            console.error("ğŸ’¥ è¿ç§»è„šæœ¬æ‰§è¡Œå¤±è´¥:", error);
            process.exit(1);
        });
}

export { migrateAllData };