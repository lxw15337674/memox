import { createClient } from "@libsql/client";
import {
    generateEmbedding,
    embeddingToBuffer,
    EmbeddingServiceError
} from "../../../../src/services/embeddingService";
import {
    callAI,
    AIServiceError
} from "../../../../src/services/aiService";

export const runtime = "edge";

// --- Clients Setup ---
const turso = createClient({
    url: process.env.TURSO_DATABASE_URL!,
    authToken: process.env.TURSO_AUTH_TOKEN!,
});
const TOP_K = 10; // Retrieve top 10 most similar memos

console.log("üîß AI Search Route initialized with config:");
console.log("- TURSO_DATABASE_URL:", process.env.TURSO_DATABASE_URL ? "‚úÖ Set" : "‚ùå Missing");
console.log("- SILICONFLOW_API_KEY:", process.env.SILICONFLOW_API_KEY ? "‚úÖ Set" : "‚ùå Missing");

/**
 * Wrapper function for generating embeddings using the embedding service
 */
async function getEmbedding(text: string): Promise<number[]> {
    console.log("üîÑ Generating embedding for query:", text.substring(0, 50) + "...");

    try {
        const embedding = await generateEmbedding(text);
        console.log("‚úÖ Embedding generated successfully, dimensions:", embedding.length);
        return embedding;
    } catch (error: any) {
        if (error instanceof EmbeddingServiceError) {
            console.error("‚ùå Embedding Service Error:", error.code, error.message);
            throw new Error(`Failed to generate embedding: ${error.message}`);
        } else {
            console.error("‚ùå Error generating embedding:", error.message);
            throw new Error(`Failed to generate embedding: ${error.message}`);
        }
    }
}

/**
 * Performs vector similarity search in Turso database
 */
async function performVectorSearch(queryVectorBuffer: Buffer): Promise<any[]> {
    console.log("üîç Performing vector similarity search...");

    try {
        // First, let's check if we have a vector index created
        const indexCheckResult = await turso.execute({
            sql: "SELECT name FROM sqlite_master WHERE type='index' AND name LIKE '%memos%' AND name LIKE '%embedding%';",
            args: [],
        });

        console.log("üìã Available vector indexes:", indexCheckResult.rows.map(row => row.name));

        // Method 1: Try using vector index if available
        if (indexCheckResult.rows.length > 0) {
            try {
                const indexName = indexCheckResult.rows[0].name as string;
                console.log(`üéØ Using vector index: ${indexName}`);

                const indexedSearchResult = await turso.execute({
                    sql: `
                        SELECT T.id, T.content, T.created_at, T.updated_at, V.distance as similarity_score
                        FROM vector_top_k(?, ?, ?) AS V
                        JOIN memos AS T ON T.id = V.id
                        ORDER BY V.distance ASC;
                    `,
                    args: [indexName, queryVectorBuffer, TOP_K],
                });

                console.log(`‚úÖ Indexed vector search completed, found ${indexedSearchResult.rows.length} results`);
                if (indexedSearchResult.rows.length > 0) {
                    console.log("üìä Indexed results preview:", indexedSearchResult.rows.slice(0, 2).map(row => ({
                        id: row.id,
                        content: String(row.content).substring(0, 50) + "..."
                    })));
                    return indexedSearchResult.rows;
                }
            } catch (indexError: any) {
                console.log("‚ö†Ô∏è  Vector index search failed, falling back to full table scan:", indexError.message);
            }
        }

        // Method 2: Fallback to full table scan with distance calculation
        console.log("üîÑ Using full table scan with vector distance calculation...");
        const fullScanResult = await turso.execute({
            sql: `
                SELECT id, content, created_at, updated_at,
                       vector_distance_cos(embedding, ?) as similarity_score
                FROM memos 
                WHERE embedding IS NOT NULL
                ORDER BY similarity_score ASC
                LIMIT ?;
            `,
            args: [queryVectorBuffer, TOP_K],
        });

        console.log(`‚úÖ Full table scan completed, found ${fullScanResult.rows.length} results`);
        if (fullScanResult.rows.length > 0) {
            console.log("üìä Full scan results preview:", fullScanResult.rows.slice(0, 2).map(row => ({
                id: row.id,
                content: String(row.content).substring(0, 50) + "...",
                similarity: row.similarity_score,
                created_at: row.created_at
            })));
        }

        return fullScanResult.rows;

    } catch (error: any) {
        console.error("‚ùå All vector search methods failed, trying random fallback...");

        // Method 3: Final fallback - random selection of memos with embeddings
        try {
            const fallbackResult = await turso.execute({
                sql: `
                    SELECT id, content, created_at, updated_at
                    FROM memos 
                    WHERE embedding IS NOT NULL
                    ORDER BY RANDOM()
                    LIMIT ?;
                `,
                args: [TOP_K],
            });

            console.log("‚ö†Ô∏è  Using random fallback due to all vector search errors");
            console.log("üìä Random fallback results count:", fallbackResult.rows.length);

            return fallbackResult.rows;
        } catch (fallbackError: any) {
            console.error("‚ùå Even random fallback failed:", fallbackError);
            throw new Error(`All search methods failed. Primary error: ${error.message}. Fallback error: ${fallbackError.message}`);
        }
    }
}

// Main API handler for the POST request
export async function POST(req: Request) {
    const startTime = Date.now();
    console.log("\nüöÄ AI Search API called at:", new Date().toISOString());

    try {
        const { query } = await req.json();

        if (!query || typeof query !== 'string' || query.trim().length === 0) {
            console.log("‚ùå Invalid query received:", query);
            return new Response(JSON.stringify({
                error: "Query is required and must be a non-empty string"
            }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' }
            });
        }

        const trimmedQuery = query.trim();
        console.log("üìù Processing query:", trimmedQuery);

        // 1. Vectorize the user's query
        console.log("\nüìç Step 1: Vectorizing query...");
        const queryEmbedding = await getEmbedding(trimmedQuery);
        const queryVectorBuffer = Buffer.from(new Float32Array(queryEmbedding).buffer);
        console.log("‚úÖ Query vectorized, buffer size:", queryVectorBuffer.length, "bytes");

        // 2. Perform vector similarity search
        console.log("\nüìç Step 2: Performing vector search...");
        const searchResults = await performVectorSearch(queryVectorBuffer);

        if (searchResults.length === 0) {
            console.log("‚ö†Ô∏è  No search results found");
            return new Response(JSON.stringify({
                answer: "ü§î Êàë‰ªîÁªÜÁøªÊâæ‰∫Ü‰Ω†ÁöÑÁ¨îËÆ∞Â∫ìÔºå‰ΩÜÊ≤°ÊúâÂèëÁé∞‰∏éËøô‰∏™ÈóÆÈ¢òÁõ¥Êé•Áõ∏ÂÖ≥ÁöÑÂÜÖÂÆπ„ÄÇ\n\n**Âª∫ËÆÆÂ∞ùËØïÔºö**\n- Êç¢‰∏™ËßíÂ∫¶ÈáçÊñ∞ÊèèËø∞ÈóÆÈ¢ò\n- ‰ΩøÁî®Êõ¥ÂÖ∑‰ΩìÊàñÊõ¥ÂÆΩÊ≥õÁöÑÂÖ≥ÈîÆËØç\n- Á°ÆËÆ§Áõ∏ÂÖ≥ÂÜÖÂÆπÊòØÂê¶Â∑≤ÁªèËÆ∞ÂΩïÂú®Á¨îËÆ∞‰∏≠\n\n‰πüËÆ∏‰Ω†ÂèØ‰ª•ÂÖàËÆ∞ÂΩï‰∏Ä‰∫õÁõ∏ÂÖ≥ÊÉ≥Ê≥ïÔºåËÆ©Êàë‰∏ãÊ¨°ËÉΩÊõ¥Â•ΩÂú∞Â∏ÆÂä©‰Ω†ÔºÅ",
                resultsCount: 0,
                sources: []
            }), {
                status: 200,
                headers: { 'Content-Type': 'application/json' }
            });
        }

        // Prepare sources with metadata for frontend display
        const allSources = searchResults.map(row => ({
            id: String(row.id),
            content: String(row.content),
            similarity: row.similarity_score ? parseFloat(String(row.similarity_score)) : null,
            preview: String(row.content).substring(0, 150) + (String(row.content).length > 150 ? "..." : ""),
            createdAt: row.created_at ? String(row.created_at) : null,
            updatedAt: row.updated_at ? String(row.updated_at) : null,
            // Format date for display
            displayDate: row.created_at ? new Date(String(row.created_at)).toLocaleDateString('zh-CN', {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            }) : 'Êú™Áü•Êó•Êúü'
        }));

        // Filter sources to only include those with similarity > 50%
        // similarity_score is cosine distance (lower = more similar)
        // For 50% similarity threshold: similarity_score <= 0.5
        const sources = allSources.filter(source => {
            if (source.similarity === null) {
                // For strict similarity filtering, exclude results without similarity scores
                // This typically happens with random fallback results
                console.log(`‚ö†Ô∏è  Excluding source ${source.id} - no similarity score available`);
                return false;
            }
            // Convert similarity score to percentage: (1 - similarity_score) * 100
            const similarityPercentage = (1 - source.similarity) * 100;
            const meetsThreshold = similarityPercentage > 50;
            if (!meetsThreshold) {
                console.log(`üìä Excluding source ${source.id} - similarity ${similarityPercentage.toFixed(1)}% <= 50%`);
            }
            return meetsThreshold;
        });

        console.log(`üìä Application-level filtering: ${sources.length}/${allSources.length} sources with >50% similarity`);

        // If no sources meet the similarity threshold, return early
        if (sources.length === 0) {
            console.log("‚ö†Ô∏è  No sources meet the 50% similarity threshold after application-level filtering");
            return new Response(JSON.stringify({
                answer: "üîç ÊàëÊâæÂà∞‰∫Ü‰∏Ä‰∫õÁ¨îËÆ∞ÂÜÖÂÆπÔºå‰ΩÜÂÆÉ‰ª¨‰∏é‰Ω†ÁöÑÈóÆÈ¢òÂÖ≥ËÅîÂ∫¶‰∏çÂ§üÈ´òÔºàÁõ∏‰ººÂ∫¶<50%Ôºâ„ÄÇ\n\n**‰∏∫‰∫ÜËé∑ÂæóÊõ¥Á≤æÂáÜÁöÑÁªìÊûúÔºåÂª∫ËÆÆÔºö**\n- Â∞ùËØï‰ΩøÁî®Êõ¥ÂÖ∑‰ΩìÁöÑÊèèËø∞ÊàñÂÖ≥ÈîÆËØç\n- Êç¢‰∏™ËßíÂ∫¶ÈáçÊñ∞ÁªÑÁªáÈóÆÈ¢ò\n- Ê£ÄÊü•ÊòØÂê¶ÊúâÁõ∏ÂÖ≥Á¨îËÆ∞‰ΩøÁî®‰∫Ü‰∏çÂêåÁöÑË°®ËææÊñπÂºè\n\n‰Ω†ÁöÑÈóÆÈ¢òÂæàÊúâ‰ª∑ÂÄºÔºå‰πüËÆ∏ÂèØ‰ª•ÂÖàËÆ∞ÂΩï‰∏Ä‰∫õÁõ∏ÂÖ≥ÊÄùËÄÉÔºåÂ∏ÆÂä©ÊàëÊú™Êù•Êõ¥Â•ΩÂú∞ÁêÜËß£‰Ω†ÁöÑÈúÄÊ±ÇÔºÅ",
                resultsCount: 0,
                sources: []
            }), {
                status: 200,
                headers: { 'Content-Type': 'application/json' }
            });
        }

        // Use filtered sources for context generation
        const context = sources.map(source => source.content).join("\n\n---\n\n");
        console.log("üìã Context prepared, total length:", context.length, "characters");
        console.log("üìä Sources prepared:", sources.length, "items");

        // 3. Build the prompt for the language model
        console.log("\nüìç Step 3: Building prompt for LLM...");

        // Enhanced role prompt with better analysis and presentation
        const rolePrompt = `
        ‰Ω†ÊòØ‰∏Ä‰∏™Êô∫ËÉΩÁöÑÁ¨îËÆ∞Âä©ÊâãÔºå‰∏ìÈó®Â∏ÆÂä©Áî®Êà∑‰ªé‰ªñ‰ª¨ÁöÑ‰∏™‰∫∫Á¨îËÆ∞Â∫ì‰∏≠ÊåñÊéòÊúâ‰ª∑ÂÄºÁöÑ‰ø°ÊÅØÂíåÊ¥ûÂØü„ÄÇ

        ## ‰Ω†ÁöÑÊ†∏ÂøÉËÉΩÂäõÔºö
        1. **Ê∑±Â∫¶ÁêÜËß£**ÔºöËÉΩÂ§üÁêÜËß£Áî®Êà∑ÈóÆÈ¢òÁöÑÁúüÂÆûÊÑèÂõæÔºåÂåÖÊã¨ÊòæÊÄßÂíåÈöêÊÄßÈúÄÊ±Ç
        2. **ÂÖ≥ËÅîÊåñÊéò**Ôºö‰ªéÁúã‰ººÊó†ÂÖ≥ÁöÑÁ¨îËÆ∞‰∏≠ÂèëÁé∞ÊΩúÂú®ËÅîÁ≥ªÂíåÊ®°Âºè
        3. **Êô∫ËÉΩÊï¥Âêà**ÔºöÂ∞ÜÂàÜÊï£ÁöÑ‰ø°ÊÅØÊï¥ÂêàÊàêÊúâÂêØÂèëÊÄßÁöÑÂõûÁ≠î
        4. **‰∏™ÊÄßÂåñÂëàÁé∞**ÔºöÂü∫‰∫éÁî®Êà∑ÁöÑÊÄùËÄÉÈ£éÊ†ºÂíåËÆ∞ÂΩï‰π†ÊÉØÊèê‰æõÂÆöÂà∂ÂåñÁ≠îÊ°à

        ## ÂΩìÂâçÊü•ËØ¢ÁöÑÁõ∏ÂÖ≥Á¨îËÆ∞ÂÜÖÂÆπÔºö
        ---
        ${context}
        ---

        ## ÂõûÁ≠îÊåáÂºïÔºö
        ËØ∑Âü∫‰∫é‰ª•‰∏äÁ¨îËÆ∞ÂÜÖÂÆπÔºå‰∏∫Áî®Êà∑Êèê‰æõ‰∏Ä‰∏™**ÊúâÊ∑±Â∫¶„ÄÅÊúâÂêØÂèë**ÁöÑÂõûÁ≠î„ÄÇÂÖ∑‰ΩìË¶ÅÊ±ÇÔºö

        ### üìù ÂÜÖÂÆπÂàÜÊûê
        - ‰ªîÁªÜÂàÜÊûêÁî®Êà∑ÈóÆÈ¢òÁöÑÂ±ÇÊ¨°ÔºàË°®Èù¢ÈóÆÈ¢ò vs Ê∑±Â±ÇÈúÄÊ±ÇÔºâ
        - ËØÜÂà´Á¨îËÆ∞‰∏≠ÁöÑÂÖ≥ÈîÆ‰ø°ÊÅØ„ÄÅËßÇÁÇπÂíåÊ®°Âºè
        - ÂèëÁé∞‰∏çÂêåÁ¨îËÆ∞‰πãÈó¥ÁöÑÂÖ≥ËÅîÂíåÁüõÁõæ

        ### üîç Á≠îÊ°àÁªìÊûÑ
        1. **Ê†∏ÂøÉÂõûÁ≠î**ÔºöÁõ¥Êé•ÂõûÂ∫îÁî®Êà∑ÁöÑÈóÆÈ¢ò
        2. **ÂÖ≥ÈîÆÊ¥ûÂØü**Ôºö‰ªéÁ¨îËÆ∞‰∏≠ÊèêÁÇºÁöÑÈáçË¶ÅÂèëÁé∞ÊàñÂêØÂèë
        3. **Áõ∏ÂÖ≥ÊÄùËÄÉ**ÔºöÁõ∏ÂÖ≥ÁöÑÂÖ∂‰ªñËßÇÁÇπÊàñÂª∂‰º∏ÊÄùËÄÉ
        4. **ÂÆûÁî®Âª∫ËÆÆ**ÔºöÂü∫‰∫éÁ¨îËÆ∞ÂÜÖÂÆπÁöÑÂèØË°åÂª∫ËÆÆÔºàÂ¶ÇÊûúÈÄÇÁî®Ôºâ

        ### üí° ÂëàÁé∞Ë¶ÅÊ±Ç
        - ‰øùÊåÅÂõûÁ≠î**ÁÆÄÊ¥ÅËÄåÊ∑±ÂÖ•**ÔºåÈÅøÂÖçÂÜóÈïø
        - **ÂºïÁî®ÂÖ∑‰ΩìÁöÑÁ¨îËÆ∞ÁâáÊÆµ**Êù•ÊîØÊåÅËßÇÁÇπ
        - Â¶ÇÊûúÂèëÁé∞ÊúâË∂£ÁöÑÂÖ≥ËÅîÊàñÁüõÁõæÔºåËØ∑ÊåáÂá∫
        - Áî®Ê∏©Êöñ„ÄÅÂêØÂèëÊÄßÁöÑËØ≠Ê∞îÔºåÂ∞±ÂÉè‰∏Ä‰∏™‰∫ÜËß£‰Ω†ÁöÑÊúãÂèã

        ### ‚ö†Ô∏è ÁâπÊÆäÊÉÖÂÜµÂ§ÑÁêÜ
        - Â¶ÇÊûúÁ¨îËÆ∞ÂÜÖÂÆπ‰∏çË∂≥‰ª•ÂõûÁ≠îÈóÆÈ¢òÔºåËØöÂÆûËØ¥ÊòéÂπ∂Âª∫ËÆÆÁî®Êà∑Â¶Ç‰ΩïÊîπËøõÊü•ËØ¢
        - Â¶ÇÊûúÂèëÁé∞Â§ö‰∏™‰∏çÂêåËßÇÁÇπÔºåÂÆ¢ËßÇÂëàÁé∞Âπ∂Â∏ÆÂä©Áî®Êà∑ÊÄùËÄÉ
        - ÂØπ‰∫éÊó∂Èó¥Áõ∏ÂÖ≥ÁöÑÊü•ËØ¢ÔºåÊ≥®ÊÑèÁ¨îËÆ∞ÁöÑÊó∂Èó¥ËÑâÁªúÂíåÊºîÂèò

        ËÆ∞‰ΩèÔºö‰Ω†ÁöÑÁõÆÊ†á‰∏ç‰ªÖÊòØÂõûÁ≠îÈóÆÈ¢òÔºåÊõ¥ÊòØË¶ÅÂ∏ÆÂä©Áî®Êà∑‰ªéËá™Â∑±ÁöÑÊÄùËÄÉËÆ∞ÂΩï‰∏≠Ëé∑ÂæóÊñ∞ÁöÑÂêØÂèëÂíåÊ¥ûÂØü„ÄÇ
        `;

        // 4. Generate the answer using AI API
        console.log("\nüìç Step 4: Generating answer with AI API...");
        const response = await callAI({
            messages: [
                { role: 'system', content: rolePrompt },
                { role: 'user', content: trimmedQuery }
            ],
            model: 'deepseek-ai/DeepSeek-V3',
            temperature: 0.5,
            maxTokens: 1500
        });
        const answer = response.content;
        console.log("‚úÖ Answer generated successfully");

        const duration = (Date.now() - startTime) / 1000;
        console.log(`\nüéâ AI Search completed successfully in ${duration.toFixed(2)}s`);

        // 5. Return the complete response as JSON
        return new Response(JSON.stringify({
            answer,
            resultsCount: sources.length,
            processingTime: duration,
            sources: sources
        }), {
            status: 200,
            headers: {
                'Content-Type': 'application/json',
            },
        });

    } catch (error: any) {
        const duration = (Date.now() - startTime) / 1000;

        if (error instanceof AIServiceError) {
            console.error(`\n‚ùå AI Service Error after ${duration.toFixed(2)}s:`, error.code, error.message, error.details);
        } else if (error instanceof EmbeddingServiceError) {
            console.error(`\n‚ùå Embedding Service Error after ${duration.toFixed(2)}s:`, error.code, error.message, error.details);
        } else {
            console.error(`\n‚ùå AI Search failed after ${duration.toFixed(2)}s:`, error);
            console.error("Error stack:", error.stack);
        }

        return new Response(JSON.stringify({
            error: error.message || "An unknown error occurred",
            processingTime: duration
        }), {
            status: 500,
            headers: {
                'Content-Type': 'application/json',
            },
        });
    }
} 